{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _excluded = [\"scrollPosition\", \"dimensions\", \"parallaxFactor\", \"style\", \"AnimatedImageComponent\"];\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport React, { Component } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport ActivityIndicator from \"react-native-web/dist/exports/ActivityIndicator\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport styles from \"./ParallaxImage.style\";\nexport var ParallaxImageStatus;\n\n(function (ParallaxImageStatus) {\n  ParallaxImageStatus[ParallaxImageStatus[\"LOADING\"] = 1] = \"LOADING\";\n  ParallaxImageStatus[ParallaxImageStatus[\"LOADED\"] = 2] = \"LOADED\";\n  ParallaxImageStatus[ParallaxImageStatus[\"TRANSITION_FINISHED\"] = 3] = \"TRANSITION_FINISHED\";\n  ParallaxImageStatus[ParallaxImageStatus[\"ERROR\"] = 4] = \"ERROR\";\n})(ParallaxImageStatus || (ParallaxImageStatus = {}));\n\nvar ParallaxImage = function (_Component) {\n  _inherits(ParallaxImage, _Component);\n\n  var _super = _createSuper(ParallaxImage);\n\n  function ParallaxImage(props) {\n    var _this;\n\n    _classCallCheck(this, ParallaxImage);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"_container\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"_mounted\", void 0);\n\n    _this.state = {\n      offset: 0,\n      width: 0,\n      height: 0,\n      status: ParallaxImageStatus.LOADING,\n      animOpacity: new Animated.Value(0)\n    };\n    _this._onLoad = _this._onLoad.bind(_assertThisInitialized(_this));\n    _this._onError = _this._onError.bind(_assertThisInitialized(_this));\n    _this._measureLayout = _this._measureLayout.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(ParallaxImage, [{\n    key: \"setNativeProps\",\n    value: function setNativeProps(nativeProps) {\n      var _this$_container;\n\n      (_this$_container = this._container) === null || _this$_container === void 0 ? void 0 : _this$_container.setNativeProps(nativeProps);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      this._mounted = true;\n      setTimeout(function () {\n        _this2._measureLayout();\n      }, 0);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._mounted = false;\n    }\n  }, {\n    key: \"_measureLayout\",\n    value: function _measureLayout() {\n      var _this3 = this;\n\n      if (this._container) {\n        var _this$props = this.props,\n            dimensions = _this$props.dimensions,\n            carouselRef = _this$props.carouselRef;\n        var nodeHandle = findNodeHandle(carouselRef);\n\n        if (carouselRef && nodeHandle) {\n          this._container.measureLayout(nodeHandle, function (x, y, width, height) {\n            var offset = _this3.props.vertical ? y - (_this3.props.sliderHeight - _this3.props.itemHeight) / 2 : x - (_this3.props.sliderWidth - _this3.props.itemWidth) / 2;\n\n            _this3.setState({\n              offset: offset,\n              width: dimensions && dimensions.width ? dimensions.width : Math.ceil(width),\n              height: dimensions && dimensions.height ? dimensions.height : Math.ceil(height)\n            });\n          }, function () {});\n        }\n      }\n    }\n  }, {\n    key: \"_onLoad\",\n    value: function _onLoad(event) {\n      var _this4 = this;\n\n      var animOpacity = this.state.animOpacity;\n      var _this$props2 = this.props,\n          fadeDuration = _this$props2.fadeDuration,\n          onLoad = _this$props2.onLoad;\n\n      if (!this._mounted) {\n        return;\n      }\n\n      this.setState({\n        status: ParallaxImageStatus.LOADED\n      });\n\n      if (onLoad) {\n        onLoad(event);\n      }\n\n      Animated.timing(animOpacity, {\n        toValue: 1,\n        duration: fadeDuration,\n        easing: Easing.out(Easing.quad),\n        isInteraction: false,\n        useNativeDriver: true\n      }).start(function () {\n        _this4.setState({\n          status: ParallaxImageStatus.TRANSITION_FINISHED\n        });\n      });\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(event) {\n      var onError = this.props.onError;\n      this.setState({\n        status: ParallaxImageStatus.ERROR\n      });\n\n      if (onError) {\n        onError(event);\n      }\n    }\n  }, {\n    key: \"image\",\n    get: function get() {\n      var _this$state = this.state,\n          status = _this$state.status,\n          animOpacity = _this$state.animOpacity,\n          offset = _this$state.offset,\n          width = _this$state.width,\n          height = _this$state.height;\n\n      var _this$props3 = this.props,\n          scrollPosition = _this$props3.scrollPosition,\n          dimensions = _this$props3.dimensions,\n          parallaxFactor = _this$props3.parallaxFactor,\n          style = _this$props3.style,\n          AnimatedImageComponent = _this$props3.AnimatedImageComponent,\n          other = _objectWithoutProperties(_this$props3, _excluded);\n\n      var parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;\n      var requiredStyles = {\n        position: 'relative'\n      };\n      var dynamicStyles = {\n        width: this.props.vertical ? width : width + parallaxPadding * 2,\n        height: this.props.vertical ? height + parallaxPadding * 2 : height,\n        opacity: animOpacity,\n        transform: scrollPosition ? [{\n          translateX: !this.props.vertical ? scrollPosition.interpolate({\n            inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],\n            outputRange: [-parallaxPadding, parallaxPadding],\n            extrapolate: 'clamp'\n          }) : 0\n        }, {\n          translateY: this.props.vertical ? scrollPosition.interpolate({\n            inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],\n            outputRange: [-parallaxPadding, parallaxPadding],\n            extrapolate: 'clamp'\n          }) : 0\n        }] : []\n      };\n      return React.createElement(AnimatedImageComponent, _extends({}, other, {\n        style: [styles.image, style, requiredStyles, dynamicStyles],\n        onLoad: this._onLoad,\n        onError: status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined\n      }));\n    }\n  }, {\n    key: \"spinner\",\n    get: function get() {\n      var status = this.state.status;\n      var _this$props4 = this.props,\n          showSpinner = _this$props4.showSpinner,\n          spinnerColor = _this$props4.spinnerColor;\n      return status === ParallaxImageStatus.LOADING && showSpinner ? React.createElement(View, {\n        style: styles.loaderContainer\n      }, React.createElement(ActivityIndicator, {\n        size: \"small\",\n        color: spinnerColor,\n        animating: true\n      })) : false;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var containerStyle = this.props.containerStyle;\n      return React.createElement(View, {\n        ref: function ref(c) {\n          _this5._container = c;\n        },\n        pointerEvents: \"none\",\n        style: [containerStyle, styles.container],\n        onLayout: this._measureLayout\n      }, this.image, this.spinner);\n    }\n  }]);\n\n  return ParallaxImage;\n}(Component);\n\nexport { ParallaxImage as default };\n\n_defineProperty(ParallaxImage, \"defaultProps\", {\n  containerStyle: {},\n  fadeDuration: 500,\n  parallaxFactor: 0.3,\n  showSpinner: true,\n  spinnerColor: 'rgba(0, 0, 0, 0.4)',\n  AnimatedImageComponent: Animated.Image\n});","map":{"version":3,"sources":["ParallaxImage.tsx"],"names":["ParallaxImageStatus","ParallaxImage","containerStyle","fadeDuration","parallaxFactor","showSpinner","spinnerColor","AnimatedImageComponent","Animated","Image","constructor","offset","width","height","status","animOpacity","setNativeProps","componentDidMount","setTimeout","componentWillUnmount","_measureLayout","carouselRef","nodeHandle","findNodeHandle","y","x","dimensions","Math","_onLoad","onLoad","LOADED","toValue","duration","easing","Easing","isInteraction","useNativeDriver","TRANSITION_FINISHED","_onError","onError","ERROR","other","parallaxPadding","requiredStyles","position","dynamicStyles","opacity","transform","scrollPosition","translateX","inputRange","outputRange","extrapolate","translateY","styles","loaderContainer","render","c"],"mappings":"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","sourcesContent":["// Parallax effect inspired by https://github.com/oblador/react-native-parallax/\n\nimport React, { Component } from 'react';\nimport {\n    View,\n    Animated,\n    Easing,\n    ActivityIndicator,\n    findNodeHandle,\n    ImageProps,\n    StyleProp,\n    ViewStyle,\n    NativeSyntheticEvent,\n    ImageLoadEventData,\n    ImageErrorEventData\n} from 'react-native';\nimport styles from './ParallaxImage.style';\n\ntype VerticalProps = {\n    vertical: true;\n    sliderHeight: number; // passed from <Carousel />\n    itemHeight: number; // passed from <Carousel />\n}\ntype HorizontalProps = {\n    vertical: false;\n    sliderWidth: number; // passed from <Carousel />\n    itemWidth: number; // passed from <Carousel />\n}\n\ntype ParallaxImageProps = {\n  carouselRef: Parameters<typeof findNodeHandle>[0]; // passed from <Carousel />\n  scrollPosition: Animated.Value | undefined; // passed from <Carousel />\n  containerStyle: StyleProp<ViewStyle>;\n  dimensions?: {\n    width: number;\n    height: number;\n  };\n  fadeDuration: number;\n  parallaxFactor: number;\n  showSpinner: boolean;\n  spinnerColor: string;\n  AnimatedImageComponent: typeof Animated.Image;\n} & ImageProps & (VerticalProps | HorizontalProps);\n\nexport enum ParallaxImageStatus {\n    'LOADING' = 1,\n    'LOADED' = 2,\n    'TRANSITION_FINISHED' = 3,\n    'ERROR' = 4\n}\n\ntype ParallaxImageState = {\n  offset: number;\n  width: number;\n  height: number;\n  status: ParallaxImageStatus;\n  animOpacity: Animated.Value;\n};\n\nexport default class ParallaxImage extends Component<\n  ParallaxImageProps,\n  ParallaxImageState\n> {\n  static defaultProps = {\n      containerStyle: {},\n      fadeDuration: 500,\n      parallaxFactor: 0.3,\n      showSpinner: true,\n      spinnerColor: 'rgba(0, 0, 0, 0.4)',\n      AnimatedImageComponent: Animated.Image\n  };\n\n  _container?: View | null;\n  _mounted?: boolean;\n\n  constructor (props: ParallaxImageProps) {\n      super(props);\n      this.state = {\n          offset: 0,\n          width: 0,\n          height: 0,\n          status: ParallaxImageStatus.LOADING,\n          animOpacity: new Animated.Value(0)\n      };\n      this._onLoad = this._onLoad.bind(this);\n      this._onError = this._onError.bind(this);\n      this._measureLayout = this._measureLayout.bind(this);\n  }\n\n  setNativeProps (nativeProps: { [key: string]: unknown }) {\n    this._container?.setNativeProps(nativeProps);\n  }\n\n  componentDidMount () {\n      this._mounted = true;\n\n      setTimeout(() => {\n          this._measureLayout();\n      }, 0);\n  }\n\n  componentWillUnmount () {\n      this._mounted = false;\n  }\n\n  _measureLayout () {\n      if (this._container) {\n          const {\n              dimensions,\n              carouselRef\n          } = this.props;\n\n          const nodeHandle = findNodeHandle(carouselRef);\n\n          if (carouselRef && nodeHandle) {\n              this._container.measureLayout(\n                  nodeHandle,\n                  (x, y, width, height) => {\n                      const offset = this.props.vertical ?\n                          y - (this.props.sliderHeight - this.props.itemHeight) / 2 :\n                          x - (this.props.sliderWidth - this.props.itemWidth) / 2;\n\n                      this.setState({\n                          offset: offset,\n                          width:\n                dimensions && dimensions.width ?\n                    dimensions.width :\n                    Math.ceil(width),\n                          height:\n                dimensions && dimensions.height ?\n                    dimensions.height :\n                    Math.ceil(height)\n                      });\n                  },\n                  // eslint-disable-next-line @typescript-eslint/no-empty-function\n                  () => {}\n              );\n          }\n      }\n  }\n\n  _onLoad (event: NativeSyntheticEvent<ImageLoadEventData>) {\n      const { animOpacity } = this.state;\n      const { fadeDuration, onLoad } = this.props;\n\n      if (!this._mounted) {\n          return;\n      }\n\n      this.setState({ status: ParallaxImageStatus.LOADED });\n\n      if (onLoad) {\n          onLoad(event);\n      }\n\n      Animated.timing(animOpacity, {\n          toValue: 1,\n          duration: fadeDuration,\n          easing: Easing.out(Easing.quad),\n          isInteraction: false,\n          useNativeDriver: true\n      }).start(() => {\n          this.setState({ status: ParallaxImageStatus.TRANSITION_FINISHED });\n      });\n  }\n\n  // If arg is missing from method signature, it just won't be called\n  _onError (event: NativeSyntheticEvent<ImageErrorEventData>) {\n      const { onError } = this.props;\n\n      this.setState({ status: ParallaxImageStatus.ERROR });\n\n      if (onError) {\n          onError(event);\n      }\n  }\n\n  get image () {\n      const { status, animOpacity, offset, width, height } = this.state;\n      const {\n          scrollPosition,\n          // False positive :( other doesn't have the dimension key\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          dimensions,\n          parallaxFactor,\n          style,\n          AnimatedImageComponent,\n          ...other\n      } = this.props;\n      const parallaxPadding = (this.props.vertical ? height : width) * parallaxFactor;\n      const requiredStyles = { position: 'relative' as const };\n      const dynamicStyles = {\n          width: this.props.vertical ? width : width + parallaxPadding * 2,\n          height: this.props.vertical ? height + parallaxPadding * 2 : height,\n          opacity: animOpacity,\n          transform: scrollPosition ?\n              [\n                  {\n                      translateX: !this.props.vertical ?\n                          scrollPosition.interpolate({\n                              inputRange: [offset - this.props.sliderWidth, offset + this.props.sliderWidth],\n                              outputRange: [-parallaxPadding, parallaxPadding],\n                              extrapolate: 'clamp'\n                          }) :\n                          0\n                  },\n                  {\n                      translateY: this.props.vertical ?\n                          scrollPosition.interpolate({\n                              inputRange: [offset - this.props.sliderHeight, offset + this.props.sliderHeight],\n                              outputRange: [-parallaxPadding, parallaxPadding],\n                              extrapolate: 'clamp'\n                          }) :\n                          0\n                  }\n              ] :\n              []\n      };\n\n      return (\n          <AnimatedImageComponent\n            {...other}\n            style={[styles.image, style, requiredStyles, dynamicStyles]}\n            onLoad={this._onLoad}\n            onError={status !== ParallaxImageStatus.TRANSITION_FINISHED ? this._onError : undefined} // prevent infinite-loop bug\n          />\n      );\n  }\n\n  get spinner () {\n      const { status } = this.state;\n      const { showSpinner, spinnerColor } = this.props;\n\n      return status === ParallaxImageStatus.LOADING && showSpinner ? (\n          <View style={styles.loaderContainer}>\n              <ActivityIndicator\n                size='small'\n                color={spinnerColor}\n                animating={true}\n              />\n          </View>\n      ) : (\n          false\n      );\n  }\n\n  render () {\n      const { containerStyle } = this.props;\n\n      return (\n          <View\n            ref={(c) => {\n                this._container = c;\n            }}\n            pointerEvents='none'\n            style={[containerStyle, styles.container]}\n            onLayout={this._measureLayout}\n          >\n              {this.image}\n              {this.spinner}\n          </View>\n      );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}